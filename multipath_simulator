<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multipath Doppler Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            background-color: #1a202c; /* gray-900 */
            border-radius: 0.5rem;
            border: 1px solid #4a5568; /* gray-600 */
        }
        .control-panel {
            background-color: #2d3748; /* gray-800 */
            border-radius: 0.5rem;
            padding: 1.5rem;
            border: 1px solid #4a5568;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568; /* gray-600 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #6366f1; /* indigo-500 */
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #6366f1; /* indigo-500 */
            cursor: pointer;
            border-radius: 50%;
        }
        /* Style for number inputs */
        input[type="number"] {
            -moz-appearance: textfield;
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-indigo-400">Multipath & Doppler Simulator</h1>
            <p class="text-lg text-gray-400 mt-2">Visualize how Doppler shifts and phase differences create signal fading.</p>
        </header>

        <!-- Main Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Controls Column -->
            <div class="lg:col-span-1 flex flex-col gap-6">
                <div class="control-panel">
                    <h2 class="text-2xl font-semibold mb-4 text-center">Controls</h2>
                    
                    <!-- Path 1 Controls -->
                    <div class="mb-6 p-4 border border-blue-500 rounded-lg">
                        <h3 class="text-lg font-medium text-blue-400 mb-3">Path 1 (Blue)</h3>
                        <div class="mb-3">
                            <label for="doppler1" class="block mb-1 text-sm">Doppler Shift</label>
                            <div class="flex items-center gap-2">
                                <input type="range" class="flex-grow" id="doppler1" min="-10" max="10" value="1" step="0.1">
                                <input type="number" id="doppler1Input" min="-10" max="10" step="0.1" class="w-20 bg-gray-700 rounded p-1 text-center font-mono text-sm">
                                <span class="w-6 text-left text-sm text-gray-400">Hz</span>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="amp1" class="block mb-1 text-sm">Amplitude</label>
                            <div class="flex items-center gap-2">
                                <input type="range" class="flex-grow" id="amp1" min="0" max="1" value="0.8" step="0.05">
                                <input type="number" id="amp1Input" min="0" max="1" step="0.05" class="w-20 bg-gray-700 rounded p-1 text-center font-mono text-sm">
                            </div>
                        </div>
                        <div>
                            <label for="phase1" class="block mb-1 text-sm">Phase Shift</label>
                            <div class="flex items-center gap-2">
                                <input type="range" class="flex-grow" id="phase1" min="-180" max="180" value="0" step="1">
                                <input type="number" id="phase1Input" min="-180" max="180" step="1" class="w-20 bg-gray-700 rounded p-1 text-center font-mono text-sm">
                                <span class="w-6 text-left text-sm text-gray-400">deg</span>
                            </div>
                        </div>
                    </div>

                    <!-- Path 2 Controls -->
                    <div class="mb-6 p-4 border border-green-500 rounded-lg">
                        <h3 class="text-lg font-medium text-green-400 mb-3">Path 2 (Green)</h3>
                        <div class="mb-3">
                            <label for="doppler2" class="block mb-1 text-sm">Doppler Shift</label>
                            <div class="flex items-center gap-2">
                                <input type="range" class="flex-grow" id="doppler2" min="-10" max="10" value="-0.5" step="0.1">
                                <input type="number" id="doppler2Input" min="-10" max="10" step="0.1" class="w-20 bg-gray-700 rounded p-1 text-center font-mono text-sm">
                                <span class="w-6 text-left text-sm text-gray-400">Hz</span>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="amp2" class="block mb-1 text-sm">Amplitude</label>
                             <div class="flex items-center gap-2">
                                <input type="range" class="flex-grow" id="amp2" min="0" max="1" value="0.7" step="0.05">
                                <input type="number" id="amp2Input" min="0" max="1" step="0.05" class="w-20 bg-gray-700 rounded p-1 text-center font-mono text-sm">
                            </div>
                        </div>
                        <div>
                            <label for="phase2" class="block mb-1 text-sm">Phase Shift</label>
                            <div class="flex items-center gap-2">
                                <input type="range" class="flex-grow" id="phase2" min="-180" max="180" value="0" step="1">
                                <input type="number" id="phase2Input" min="-180" max="180" step="1" class="w-20 bg-gray-700 rounded p-1 text-center font-mono text-sm">
                                <span class="w-6 text-left text-sm text-gray-400">deg</span>
                            </div>
                        </div>
                    </div>

                    <!-- Simulation Control -->
                    <div class="flex justify-center mt-4">
                        <button id="pauseButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg transition-colors duration-300">Pause</button>
                    </div>
                </div>
                
                 <div class="control-panel text-sm text-gray-300">
                    <h3 class="text-lg font-semibold mb-2 text-center">How It Works</h3>
                    <p class="mb-2"><strong class="text-indigo-400">Concept:</strong> The simulator shows two signals arriving at a receiver via different paths. Each path can have a different Doppler shift and phase.</p>
                    <p class="mb-2"><strong class="text-indigo-400">Phase Shift:</strong> This simulates the initial phase difference between the paths, often caused by them traveling different distances to the receiver.</p>
                    <p class="mb-2"><strong class="text-indigo-400">Interference:</strong> When the signals (phasors) are in-phase (point in the same direction), they add up, boosting the signal strength. This is <span class="text-cyan-400">constructive interference</span>.</p>
                    <p><strong class="text-indigo-400">Fading:</strong> When they are out-of-phase (point opposite), they cancel out, causing a drop in signal strength (a "fade"). This is <span class="text-red-400">destructive interference</span>.</p>
                 </div>
            </div>
            
            <!-- Visualizations Column -->
            <div class="lg:col-span-2 flex flex-col gap-6">
                <div>
                    <h2 class="text-xl font-semibold mb-2 text-center">Combined Waveform</h2>
                    <canvas id="waveCanvas" width="800" height="250"></canvas>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h2 class="text-xl font-semibold mb-2 text-center">Phasor Diagram</h2>
                        <canvas id="phasorCanvas" width="400" height="400"></canvas>
                    </div>
                    <div>
                        <h2 class="text-xl font-semibold mb-2 text-center">Received Signal Strength</h2>
                        <canvas id="rssiCanvas" width="400" height="400"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Simulation State ---
        let simParams = {
            doppler1: 1.0,
            amp1: 0.8,
            phase1: 0,
            doppler2: -0.5,
            amp2: 0.7,
            phase2: 0
        };
        
        let time = 0;
        let isPlaying = true;
        let animationFrameId;
        
        const rssiHistory = [];
        const MAX_RSSI_HISTORY = 400;

        // --- DOM Element Retrieval ---
        const waveCanvas = document.getElementById('waveCanvas');
        const phasorCanvas = document.getElementById('phasorCanvas');
        const rssiCanvas = document.getElementById('rssiCanvas');
        const waveCtx = waveCanvas.getContext('2d');
        const phasorCtx = phasorCanvas.getContext('2d');
        const rssiCtx = rssiCanvas.getContext('2d');
        const pauseButton = document.getElementById('pauseButton');

        /**
         * Links a slider and a number input to a parameter in the simParams object.
         * Ensures they stay in sync and validates/clamps input.
         * @param {string} sliderId - The ID of the range slider element.
         * @param {string} inputId - The ID of the number input element.
         * @param {string} paramKey - The key in the simParams object.
         * @param {number} precision - The number of decimal places for the display value.
         */
        function setupControlSync(sliderId, inputId, paramKey, precision) {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);

            // Set initial values from simParams
            slider.value = simParams[paramKey];
            input.value = simParams[paramKey].toFixed(precision);

            // Event listener for the slider
            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                simParams[paramKey] = value;
                input.value = value.toFixed(precision);
            });

            // Event listener for the number input
            input.addEventListener('change', () => {
                let value = parseFloat(input.value);
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);

                if (isNaN(value)) {
                    value = simParams[paramKey]; // Revert if input is not a valid number
                }

                // Clamp the value to the allowed range
                const clampedValue = Math.max(min, Math.min(max, value));
                
                simParams[paramKey] = clampedValue;
                slider.value = clampedValue;
                input.value = clampedValue.toFixed(precision); // Update input to show the clamped value
            });
        }

        function setupAllControls() {
            setupControlSync('doppler1', 'doppler1Input', 'doppler1', 1);
            setupControlSync('amp1', 'amp1Input', 'amp1', 2);
            setupControlSync('phase1', 'phase1Input', 'phase1', 0);
            setupControlSync('doppler2', 'doppler2Input', 'doppler2', 1);
            setupControlSync('amp2', 'amp2Input', 'amp2', 2);
            setupControlSync('phase2', 'phase2Input', 'phase2', 0);

            pauseButton.addEventListener('click', () => {
                isPlaying = !isPlaying;
                pauseButton.textContent = isPlaying ? 'Pause' : 'Play';
                if (isPlaying) {
                    animate();
                } else {
                    cancelAnimationFrame(animationFrameId);
                }
            });
            
            window.addEventListener('resize', handleResize);
        }

        // --- Canvas Sizing and Responsiveness ---
        function handleResize() {
            waveCanvas.width = waveCanvas.clientWidth;
            waveCanvas.height = waveCanvas.clientHeight;
            phasorCanvas.width = phasorCanvas.clientWidth;
            phasorCanvas.height = phasorCanvas.clientHeight;
            rssiCanvas.width = rssiCanvas.clientWidth;
            rssiCanvas.height = rssiCanvas.clientHeight;
            if (!isPlaying) { draw(); }
        }
        
        // --- Drawing Functions ---
        function drawWaveCanvas() {
            const w = waveCanvas.width, h = waveCanvas.height, midY = h / 2;
            waveCtx.clearRect(0, 0, w, h);
            waveCtx.lineWidth = 2;
            const y_scale = h / 4.5;
            const phase1Rad = simParams.phase1 * Math.PI / 180;
            const phase2Rad = simParams.phase2 * Math.PI / 180;

            const drawPath = (color, doppler, amp, phaseRad) => {
                waveCtx.strokeStyle = color;
                waveCtx.beginPath();
                for (let x = 0; x < w; x++) {
                    const t_local = x / w;
                    const angle = 2 * Math.PI * doppler * (time + t_local) + phaseRad;
                    const y = midY - amp * Math.sin(angle) * y_scale;
                    if (x === 0) waveCtx.moveTo(x, y); else waveCtx.lineTo(x, y);
                }
                waveCtx.stroke();
            };
            drawPath('#3b82f6', simParams.doppler1, simParams.amp1, phase1Rad);
            drawPath('#22c55e', simParams.doppler2, simParams.amp2, phase2Rad);
            
            waveCtx.strokeStyle = '#eab308';
            waveCtx.lineWidth = 3;
            waveCtx.beginPath();
            for (let x = 0; x < w; x++) {
                const t_local = x / w;
                const angle1 = 2 * Math.PI * simParams.doppler1 * (time + t_local) + phase1Rad;
                const y1 = simParams.amp1 * Math.sin(angle1);
                const angle2 = 2 * Math.PI * simParams.doppler2 * (time + t_local) + phase2Rad;
                const y2 = simParams.amp2 * Math.sin(angle2);
                const y_sum = midY - (y1 + y2) * y_scale;
                if (x === 0) waveCtx.moveTo(x, y_sum); else waveCtx.lineTo(x, y_sum);
            }
            waveCtx.stroke();
        }

        function drawPhasorCanvas() {
            const w = phasorCanvas.width, h = phasorCanvas.height;
            const centerX = w / 2, centerY = h / 2;
            const scale = Math.min(w, h) / 4.5;
            phasorCtx.clearRect(0, 0, w, h);

            const angle1 = 2 * Math.PI * simParams.doppler1 * time + (simParams.phase1 * Math.PI / 180);
            const x1 = simParams.amp1 * Math.cos(angle1) * scale;
            const y1 = simParams.amp1 * Math.sin(angle1) * scale;
            const angle2 = 2 * Math.PI * simParams.doppler2 * time + (simParams.phase2 * Math.PI / 180);
            const x2 = simParams.amp2 * Math.cos(angle2) * scale;
            const y2 = simParams.amp2 * Math.sin(angle2) * scale;
            const sumX = x1 + x2, sumY = y1 + y2;

            phasorCtx.strokeStyle = '#4a5568';
            phasorCtx.lineWidth = 0.5;
            phasorCtx.beginPath();
            phasorCtx.moveTo(0, centerY); phasorCtx.lineTo(w, centerY);
            phasorCtx.moveTo(centerX, 0); phasorCtx.lineTo(centerX, h);
            phasorCtx.stroke();

            drawVector(phasorCtx, centerX, centerY, x1, y1, '#3b82f6', 3);
            drawVector(phasorCtx, centerX, centerY, x2, y2, '#22c55e', 3);
            drawVector(phasorCtx, centerX, centerY, sumX, sumY, '#eab308', 4);
            
            return Math.sqrt(sumX * sumX + sumY * sumY) / scale;
        }
        
        function drawVector(ctx, startX, startY, vx, vy, color, lineWidth) {
            ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = lineWidth;
            const endX = startX + vx, endY = startY - vy;
            ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke();
            const headlen = 10, angle = Math.atan2(endY - startY, endX - startX);
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath(); ctx.fill();
        }

        function drawRssiCanvas(currentRssi) {
            rssiHistory.push(currentRssi);
            if (rssiHistory.length > MAX_RSSI_HISTORY) rssiHistory.shift();

            const w = rssiCanvas.width, h = rssiCanvas.height;
            rssiCtx.clearRect(0, 0, w, h);
            rssiCtx.strokeStyle = '#4a5568';
            rssiCtx.fillStyle = '#9ca3af';
            rssiCtx.font = '12px Inter';
            rssiCtx.textAlign = 'right';
            
            const maxRssi = simParams.amp1 + simParams.amp2;
            const levels = 5;
            for(let i = 0; i <= levels; i++) {
                const val = (maxRssi / levels) * i;
                if(maxRssi === 0) continue; // Avoid division by zero
                const y = h - (val / maxRssi) * (h - 20) - 10;
                rssiCtx.beginPath();
                rssiCtx.moveTo(35, y);
                rssiCtx.lineTo(w, y);
                rssiCtx.stroke();
                rssiCtx.fillText(val.toFixed(1), 30, y + 4);
            }
            
            rssiCtx.strokeStyle = '#eab308';
            rssiCtx.lineWidth = 2.5;
            rssiCtx.beginPath();
            for (let i = 0; i < rssiHistory.length; i++) {
                const x = (i / (MAX_RSSI_HISTORY - 1)) * w;
                let y = h - 10; // Default to bottom if maxRssi is 0
                if (maxRssi > 0) {
                     y = h - (rssiHistory[i] / maxRssi) * (h - 20) - 10;
                }
                if (i === 0) rssiCtx.moveTo(x, y); else rssiCtx.lineTo(x, y);
            }
            rssiCtx.stroke();
        }

        // --- Main Animation Loop ---
        function draw() {
            drawWaveCanvas();
            const currentRssi = drawPhasorCanvas();
            drawRssiCanvas(currentRssi);
        }
        
        function animate() {
            if (!isPlaying) return;
            time += 0.005;
            draw();
            animationFrameId = requestAnimationFrame(animate);
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            setupAllControls();
            handleResize();
            animate();
        });

    </script>
</body>
</html>
